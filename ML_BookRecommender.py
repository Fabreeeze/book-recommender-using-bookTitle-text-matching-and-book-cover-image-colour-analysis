# -*- coding: utf-8 -*-
"""book recommender cost ratings.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F93cuq7prSRxmLYNa37HDIycX2rSUJeU
"""


def recommend_book(upperCost, lowerRating,genre, keywords):
    import pandas as pd
    import requests
    from PIL import Image
    from io import BytesIO
    import matplotlib.pyplot as plt
    import seaborn as sns
    

    
    color_labels = {
        'Red': (255, 0, 0),
        'Green': (0, 255, 0),
        'Blue': (0, 0, 255),
        'Black': (0, 0, 0),
        'White': (255, 255, 255),
        'Yellow': (255, 255, 0),
        'Orange': (255, 165, 0),
        'Purple': (128, 0, 128),
        'Pink': (255, 192, 203),
        'Dark Green': (0, 128, 0),
        'Navy Blue': (0, 0, 128),
        'Red-Orange': (255, 69, 0),
        'Ivory': (255, 255, 240),
        'Olive': (128, 128, 0),
        'Magenta': (255, 0, 255),
        'Maroon': (128, 0, 0),
    }

    path = 'final_updated_with_nearestMatchedColors_subset_dataset_new.xlsx'



    subset = pd.read_excel(path)
    print("dataset read")


    

    # def get_books_by_dominant_color(genre, upper_cost_limit, lower_ratings_limit):
    #     # Filter the dataset based on genre, upper cost limit, and lower ratings limit
    #     filtered_dataset = subset[(subset['category_name'] == genre) &
    #                             (subset['price'] <= upper_cost_limit) &
    #                             (subset['stars'] >= lower_ratings_limit)]

    #     # Group the filtered dataset by dominant colors
    #     grouped_by_color = filtered_dataset.groupby('MatchedColor')

    #     # Initialize a dictionary to store books by dominant color
    #     books_by_dominant_color = {}

    #     # Iterate through each dominant color
    #     for color, group in grouped_by_color:
    #         # Sort the books within each color group based on ratings and isbestseller
    #         sorted_group = group.sort_values(by=['stars', 'isBestSeller'], ascending=[False, False])
    #         # Select the top-rated book with isbestseller set to True for each color
    #         top_book = sorted_group.iloc[0] if not sorted_group.empty else None
    #         print(top_book)
    #         if top_book is not None:
    #             books_by_dominant_color[color] = top_book['asin']
    #         else:
    #             books_by_dominant_color[color] = None

    #     # Create a list of top-rated books for each dominant color
    #     # print("final books = ",books_by_dominant_color)
    #     result = []
    #     for i in range(7):  # Top 7 dominant colors
    #         result.append(books_by_dominant_color[ list(books_by_dominant_color.keys() )[i] ])

    #     return result

    # # Example usage
    # genre = 'Parenting & Relationships'
    # upper_cost_limit = 20
    # lower_ratings_limit = 4.5
    # books_by_color = get_books_by_dominant_color(genre, upper_cost_limit, lower_ratings_limit)
    # print(books_by_color)


    import numpy as np
    from sklearn.feature_extraction.text import CountVectorizer
    from sklearn.metrics.pairwise import cosine_similarity

    dataset = subset

    def preprocess_keywords(keywords):
        # Tokenize and lowercase keywords
        keywords = keywords.lower()
        print("here in")
        return keywords.split()

    def calculate_similarity_scores(titles, keywords):

        #to ensure that all title names are string values
        titles = [str(title) for title in titles]

        # Convert titles and keywords to bag-of-words vectors
        vectorizer = CountVectorizer().fit(titles)
        title_vectors = vectorizer.transform(titles)
        keyword_vector = vectorizer.transform([' '.join(keywords)])

        # Calculate cosine similarity between keyword vector and title vectors
        similarity_scores = cosine_similarity(title_vectors, keyword_vector)
        return similarity_scores.flatten()

    def rank_recommendations(dataset, similarity_scores):
        # Add similarity scores as a new column in the dataset
        dataset['similarity_score'] = similarity_scores

        # Rank recommendations based on similarity scores
        ranked_recommendations = dataset.sort_values(by='similarity_score', ascending=False)
        return ranked_recommendations

    def filter_recommendations(recommendations, threshold):
        # Filter recommendations based on similarity threshold
        filtered_recommendations = recommendations[recommendations['similarity_score'] >= threshold]
        return filtered_recommendations





    def sort_by_dominant_color(recommendations, genre, dominant_colors):
        dominant_color_order = dominant_colors[genre].tolist()
        recommendations.loc[:, 'color_rank'] = recommendations['MatchedColor'].apply(lambda x: dominant_color_order.index(x) if x in dominant_color_order else float('inf'))
        sorted_recommendations = recommendations.sort_values(by='color_rank')
        return sorted_recommendations.drop(columns=['color_rank'])



    def get_book_recommendations(genre, keywords, dataset, max_cost, min_ratings, dominant_colors, similarity_threshold=0.3):
        # Preprocess input keywords
        keywords = str(keywords)
        preprocessed_keywords = preprocess_keywords(keywords)

        # Filter dataset by genre
        genre_dataset = dataset[dataset['category_name'] == genre]
        # print('genre data=',genre_dataset['title'])

        # Filter dataset by maximum cost and minimum ratings
        max_cost=int(max_cost)
        min_ratings=int(min_ratings)
        # genre_dataset['price'] = pd.to_numeric(genre_dataset['price'], errors='coerce')
        # genre_dataset['stars'] = pd.to_numeric(genre_dataset['stars'], errors='coerce')

        genre_dataset = genre_dataset[(genre_dataset['price'] <= max_cost) & (genre_dataset['stars'] >= min_ratings)]

        # Calculate similarity scores for books within genre
        similarity_scores_within_genre = calculate_similarity_scores(genre_dataset['title'], preprocessed_keywords)

        # print("same genre max similariyt score",similarity_scores_within_genre.max())

        # Rank recommendations within genre
        ranked_recommendations_within_genre = rank_recommendations(genre_dataset, similarity_scores_within_genre)

        # Filter recommendations based on similarity threshold
        filtered_recommendations_within_genre = filter_recommendations(ranked_recommendations_within_genre, similarity_threshold)

        # Sort by dominant color ranking
        filtered_recommendations_within_genre = sort_by_dominant_color(filtered_recommendations_within_genre, genre, dominant_colors)


        # If not enough recommendations within genre, expand search to other genres
        if len(filtered_recommendations_within_genre) < 5:
            # Calculate similarity scores for books across genres
            similarity_scores_across_genres = calculate_similarity_scores(dataset['title'], preprocessed_keywords)

            # Rank recommendations across genres
            ranked_recommendations_across_genres = rank_recommendations(dataset, similarity_scores_across_genres)

            # Filter recommendations based on similarity threshold
            filtered_recommendations_across_genres = filter_recommendations(ranked_recommendations_across_genres, similarity_threshold)

            filtered_recommendations_across_genres = sort_by_dominant_color(filtered_recommendations_across_genres, genre, dominant_colors)


            return filtered_recommendations_within_genre, filtered_recommendations_across_genres
        else:
            tempDf = pd.DataFrame()
            return filtered_recommendations_within_genre, tempDf

    top_10_dominant_colors_by_category = pd.read_excel('top_10_colors_by_category.xlsx')
    top_10_dominant_colors_by_category.fillna("NONE")
    
    # print(top_10_dominant_colors_by_category)
    best_genre_recommendations, other_genre_recommendations = get_book_recommendations(genre, keywords, dataset, upperCost, lowerRating,top_10_dominant_colors_by_category)

    
    

    return [best_genre_recommendations, other_genre_recommendations]
